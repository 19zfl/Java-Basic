<font size="6" face="黑体">方法·前言:</font>

- ### 当代码都是完成两个int类型数据的和，相同的代码写了n遍（只不过这几次的求和数据不同），代码没有得到重复使用。

- ### 应该在java语言里面有这样的一种机制：

  - 某个功能代码只需要写一遍；
  - 要使用这个功能，只需要给这个功能传递具体数据；
  - 这个功能完成之后返回一个最终的结果。

  *这样代码就可以重复使用，提高代码复用率。【这就是“**方法”**】*

- ### 使用这个方法我们称为“调用/invoke”

### 方法的本质是什么？

​	*方法就是一段代码片段，并且这段代码片段可以完成某个特定的功能，并且可以被重复使用。*

方法定义在类体中，在一个类当中可以定义多个方法，方法编写的位置没有先后顺序，可以随意。

方法体由Java语句构成，方法体当中的代码遵循自上而下的顺序依次执行。

<font color="red" face="黑体">方法体内不能再定义方法。</font>

# 关于Java语言当中的方法：

### 方法怎么定义，语法结构：

> [**修饰符列表**] **返回值类型** **方法名**（**形式参数列表**）{
>
> ​		**方法体；**
>
> }

- ### 对以上的语法结构进行解释说明：

- **关于修饰符列表：**
  
  - 可选项，非必须
  - 目前统一写成：public static【详细后面补充】
  - 方法的修饰符列表当中有static关键字的话，怎么调用这个方法？
    - 类名.方法名（实际参数列表）；
  
- **返回值类型**
  
  - 什么是返回值？
  
    - 一个方法是可以完成某个特定功能的，这个功能结束之后大多数都是需要返回最终执行结果的，执行结果可能是一个具体存在的数据，而这个具体存在的数据就是返回值。
  - 返回值类型？
    - 返回值是一种具体存在的数据，数据都是有类型的此处需要指定的是返回值的具体类型。
    - 返回值类型都可以指定哪些类型？
      - Java任意一种类型都可以，包括基本数据类型和所有的引用数据类型。
    - 也可能这个方法执行结束之后不返回任何数据，Java中规定，当一个方法执行结束之后不返回任何数据的话，返回值类型位置必须编写：void关键字
    - 返回值类型若不是void，表示这个方法执行结束之后必须返回一个具体数值，当方法执行结束的时候没有返回任何数据的话编译器报错。怎么返回呢？代码怎么编写呢？"return 值;" ，并且要求”值“的数据类型必须和"方法的返回值类型"一致。不然编译器报错。
    - 当返回值类型是void的时候，不能编写"return 值;",但需要注意，可以编写"return;"。
    - 只要带有return关键字的语句执行，return语句所在的方法结束。【不是JVM结束，是方法结束。】
  
- **方法名：**

  - 只要是合法得标识符就行
  - 最好见名知意
  - 最好是动词
  - 首字母要求要小写，后面每个单词首字母都要大写

- **形式参数列表：【简称：形参】**

  - 形参是局部变量：int a;double b;float c;String s;……
  - 形参的个数：0-N个
  - 多个形参之间用”逗号“隔开
  - 形参中起决定性作用的是形参的数据类型，形参的名字就是局部变量的名字
  - 方法在调用的时候，实际给这个方法传递的真实数据被称为：实际参数，简称实参。
  - 实参列表和形参列表必须满足：
    - 数量相同
    - 类型对应相同

  例如：

  ````java
  方法定义
      public static int sum (int 变量名, int 合法的标识符就行) {//(int a, int b)
      
  }
  方法调用
      sum(12,24)
      sum("d2d","da2") //编译器报错
  ````

  

- **方法体：**

  - 必须由大括号括起来，方法体中的代码有顺序，遵循自上而下的顺序依次执行。并且方法体由Java语句组成，每一个Java语句以”；“结尾。

### 方法怎么调用？

​	<font color="red">方法只定义不去调用是不会执行的。只有在调用的时候才会执行。</font>

​	<font color="red">方法的调用不一定在main方法中，可以在其他方法当中。</font>

​	<font color="red">只要是程序可以执行到的位置，都可以去调用其他方法。</font>

- 语法规则：(方法的修饰符列表中有static）
  - 类名.方法名(实参列表); <这是一条java语句，表示调用某个类的某个方法，传递这样的实参。>

#### 代码详解

````java
//public表示公开的
//class表示定义类
//MethodTest01是一个类名
public class MethodTest01 { //表示定义一个公开的类，起名MethodTest01，由于是公开的类，所以源文件名必须是：MethodTest01.java
    //类体
    //类体中不能直接编写java语句，除声明变量之外
    //方法出现在类体当中
    
    //public表示公开的
    //static表示静态的
    //void表示方法结束执行之后不返回任何执行数据
    //main是方法名：主方法
    //(String[] args)：形式参数列表，其中String[]是一种引用数据类型，args是一个局部变量的变量名
    //所以以下只有args这个局部变量的变量名是随意的
    //主方法就需要这样固定编写，这是程序的入口。【sun规定的，必须这样写】
    public static void main(String[] args) {
        
        //这里的方法时一定会执行的
        //main方法是JVM负责调用的，是一个入口位置
        //从这里作为起点开始执行程序
        //既然这样，我们就可以在这里编写java语句来调用其他的方法
        //调用MethodTest01的sum方法，传递两个实参
        MethodTest01的sum(int类型数值,int类型数值);
        //这里的(int类型数值,int类型数值)就是实参列表
        
        //一个方法可以被重复使用，重复调用
        int a = 190;
        MethodTest01.sum(a,399);
        
        //再次被调用
        int k = 199;
        int l = 199;
        MethodTest01.sum(k,l);
        
    }
    
    //自定义方法：不是程序的入口
    //方法作用：计算两个int类型数据的和，不要求返回结果，但是要求将结果直接输出到控制台
    //修饰符列表：public static
    //返回值类型：void
    //方法名：sum
    //形式参数列表：(int i,int j)
    //方法体：主要任务是求和之后输出计算结果
    public static void sum(int i,int j) {
        System.out.println(i + "+" + j + "=" (i+j));
    }
    
} 
````

<font color=red>注意：</font>

​		<font color=red>方法体当中的代码是有执行顺序的，遵循自上而下的顺序依次执行。</font>

​		<font color=red>*某一行代码执行不结束，就无法执行到下一行代码。*</font>

##### 调用时注意：

- 方法调用的时候实参和形参要求个数对应相同，数据类型对应相同。
- 类型不同的时候要求能够进行相应的自动类型转换
- 方法的修饰符列表当中有static关键字，完整的调用方法是：类名.方法名（实参列表)；
- 对于方法中同一个类里调用方法，”类名“可以省略不写

##### 深入return：

- 带有return关键字的Java语句只要执行，所在的方法执行结束。
- 在”同一个作用域“当中，return语句下面不能编写任何代码，因为在这些代码永远都执行不到，所以编译报错。

> 详细见：MethodTest09.java

- 在返回值类型是void的方法中使用："return;”语句。

  - 对于结果返回类型为空的方法，无法返回值，编译报错

  - > `public static void m() {`
    >
    > ​            ~~`return 10;`~~
    >
    > ​            `return;`
    >
    > `}`
    >
    > “return;”语句出现在返回值为void的方法当中，主要最作用就是结束当前方法。



---



## 方法执行内存分析

#### 方法在执行过程中，在JVM中的内存是如何分配的呢?内存是如何变化的？

1.方法只定义，不调用，是不会执行的，并且在JVM也不会给该方法分配运行所属的内存空间。只有在调用这个方法的时候，才会动态的给这个方法分配所属的内存空间。

2.在JVM内存划分上有这样三块主要的内存空间：

- 方法区内存
- 堆内区
- 栈内存

3.关于**”栈“**数据结构：

- 栈：stack，是一种数据结构
- 数据结构反应的是数据的存储形态。
- 数据结构是独立的学科，不属于任何编程语言的范畴，只不过在大多数编程语言当中要使用数据结构。
- 作为程序员需要提前精通：数据结构+算法【计算机专业必修一门课程】
- 常见的数据结构：
  - 数组
  - 队列
  - 栈
  - 链表
  - 二叉树
  - 哈希表/散列表
  - ……

4.方法代码片段存在哪里？方法执行的时候执行过程的内存在哪里分配？

- 方法代码片段属于.class字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区当中。所以JVM中的三块主要内存空间中的方法区内存最先有数据，存放了代码片段。
- 代码片段虽然在方法区内存当中只有一份，但可以被重复调用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所，在栈内存中分配。

5.方法在调用的瞬间，会给该方法分配内存空间，会在栈中发生压栈动作，方法执行结束之后，给该方法分配的内存空间全部释放，此时发生贪弹栈动作。

- 压栈：给方法分配内存
- 弹栈：释放该方法占用的内存空间

6.局部变量在”方法体“中声明，局部变量在运行阶段内存在战中分配。



### JVM模拟：

![JVM](D:\Repository\Code\Obsidian\Java Basic\Chapter 1\images\JVM.png)



### 关于栈：

##### 一览表（目前学到）：

![栈/Stack](D:\Repository\Code\Obsidian\Java Basic\Chapter 1\images\stack.png)

1.栈帧永远指向栈顶元素

2.栈顶元素处于活跃状态，其他元素静止

3.相关术语：

- 压栈/入栈/push
- 弹栈/出栈/pop

4.栈数据结构储存数据的特点是：

​	先进后出

​	后进先出

---

### 方法初步：

方法可以是重复调用的代码块，通常为了实现各种功能

**方法的定义格式：**

[方法修饰符列表] 返回值类型 方法名 (方法参数列表) {

​			方法体

}

- 方法修饰符列表

  > 是可选项，方法的修饰符可以包括：public，protected，private，abstract，static，final，synchronized，其中public，protected，private不能同时存在。

- 返回值类型

  > 如果没有返回值使用void关键字，如果存在返回值可以是基本类型和引用类型，如果存在返回值，使用return语句。Return语句后面不能再执行语句，因为不可能会执行到，编译器会发生报错。

- 方法名

  > 任意合法的标识符

- 方法参数列表

  > 参数列表可以多个，如：method(int a,int b),多个采用逗号分隔。

#### 案例内存分析：

<mark>代码：</mark>

<mark>详细见：MethodTest11.java</mark>

````java
public class MethodTest {
    //String.class,System.class,Character.class等等都在java安装目录的rt.jar包里，javase类库自带。

    public static void main(String[] args) {

        int a = 10;
        int b = 20;
        int retValue = sumInt(a,b);
        System.out.println(retValue);

    }

    public static int sumInt(int i,int j) {
        int result = i + j;
        int num = 3;
        int retValue = divide(result,num);
        return retValue;
    }

    public static int divide(int x,int y) {
        int z = x / y;
        return z;
    }

}
````

<mark>内存分析：</mark>

<img src="D:\Repository\Code\Obsidian\Java Basic\Chapter 1\images\jvmexample1.png" alt="jvmexample1"  />

